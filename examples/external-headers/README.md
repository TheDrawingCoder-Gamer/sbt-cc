# external-headers

This project shows how to include headers and source from external places.

## Add header search paths

Typically, the compilers search the headers in the same directory as the source
files and in the system directories (e.g. `/usr/include`) without specifying
additional parameters. However, you may sometimes want the compiler to search
other directories. To do so, use `cIncludes` setting for C source files and
`cxxIncludes` for C++ source files. The usage is pretty much the same as `cFlags`
and `cxxFlags`, but you need to pass `File` objects. Below is an example.


    Compile / cIncludes  := Map(
      mainExe -> Seq(
        file("/tmp/include"),
      )
    ),
    
This example adds `/tmp/include` to the header search paths in addition to
the paths that the compiler searches by default. `main.c` in this example
project refers to `EXTERNAL_VALUE` macro value which is expected to be defined
`tmp_header.h`. This example project does not have it, so, for successful
compilation of this project, please make `/tmp/include/tmp_header.h` with
just one line shown below
  
      #define EXTERNAL_VALUE "hey"
      
 ## Dynamically add header search paths
 
`cIncludes` setting is a static setting, which means that, the setting is
evaluated when `build.sbt` is loaded. In some cases, you generate header
files in another sbt task and you want to include it in the search paths.
If you know the directory where the header files are generated, you may
hard-code it in `cIndlues` setting, but such hard-code may be not ideal
because the directory may be changed if someone changes the internal behavior
of sbt task or the task may randomly choose a directory.

If you have a way to get the directory where the header files are dynamically
generated, you can add it to `cIncludeDirectories` for C or `cxxIncludeDirectories`
for C++. They are not actually settings, but tasks. They are the tasks that
return all header search paths, so you need to make a custom task and overload
them. By default, those tasks simply returns the values in `cIncludes` and
`cxxIncludes` settings.

Here is an example task `exampleHeaderGenerator` which generates `dynamic_header.h`
in `demo` directory under the managed source directory. The managed source directory
is typically under `target/scala-x.yy/src_managed`, but the version number in the
directory path may be changed with different Scala version. 

    Compile / exampleHeaderGenerator := {
      val header = (Compile / sourceManaged).value / "demo" / "dynamic_header.h"
      IO.write(header, """#define DYNAMIC_HEADER_VALUE "OK"""")
      streams.value.log.info("Generated header: " + header.toString)
      Seq(header)
    },

Typically, the tasks which generate file(s) return an instance of `Seq[File]`.
The above example task also follow that convention though it returns only one file.

If you want to include the `demo` directory generated by `exampleHeaderGenerator`,
you can overwrite `cIncludeDirectories` task as shown below.

    Compile / cIncludeDirectories := { CcPlugin.combineMaps(
      (Compile / cIncludes).value,
      Map( mainExe -> (Compile / exampleHeaderGenerator).value.map(_.getParentFile).distinct )
    ) },    
 
Do not forget to include `cIndlues` setting. Because `++` operator of Map simply
overwrites a value by another for the same key, CcPlugin provides a utility method
to combine two instnace of `Map[Target,Seq[File]]` in a way that the instances of
`Seq[File]` for the same key are concatenated.

## Dynamically add source files

The C and C++ source files can be also added pretty much in the same way as the
header files. For source files, overload `cSourceFiles` for C or `cxxSourceFiles`
for C++ instead.

Please note that those tasks should return the list of source files, not the 
directories where the source files reside. Below is an example of a task 
`exampleSourceGenerator` which generates one C source file `dynamic.c` and
an overloaded task `cSourceFiles` to merge the source files in `cSources`
setting and the one generated by `exampleSourceGenerator` task and return. 

    Compile / exampleSourceGenerator := {
      val source = (Compile / sourceManaged).value / "demo" / "dynamic.c"
      IO.write(source,
        """
          #include <stdio.h>

          void dynamic_func(){
              printf("Hello from dynamic_func().\n");
           }
        """.stripMargin)
      streams.value.log.info("Generated header: " + source.toString)
      Seq(source)
    },
    
    Compile / cSourceFiles := { CcPlugin.combineMaps(
      (Compile / cSources).value,
       Map( mainExe -> (Compile / exampleSourceGenerator).value )
    ) },
    
