import java.nio.file.Paths

import scala.sys.env
import sbt.nio.file.FileTreeView

import scala.collection.immutable.ListSet
import sbtcc._

ThisBuild / name         := "ptotobuf"
ThisBuild / version      := "0.1"
ThisBuild / scalaVersion := "2.13.1"

val cprogExe = Executable("cprog")

//-----------------------------------------------------------------------
// This sub project only hosts Google Protocol Buffer files (*.proto).
// To follow the convention of sbt-protoc plugin, all *.proto files
// should be saved in proto/src/main/protobuf directory. The *.proto
// files in that directory are automatically compiled to Java and C
// source code in this example.
//-----------------------------------------------------------------------
lazy val proto = (project in file ("proto"))
  .enablePlugins(ProtocPlugin)
  .settings(
    // The lines below compile *.proto files into Java source files
    // and C source/header files.
    //
    // Other sub projects which depend on the generated Java classes
    // should depend on this sub project.
    PB.targets in Compile := Seq(
      // Target setting to generate Java source files.
      //
      // Here "3.7.0" indicates the version of the Google Protocol Buffers
      // binary that generates the Java source files. It is automatically
      // downloaded, so you do not have to manually install it.
      PB.gens.java("3.7.0") -> (Compile / sourceManaged).value,

      // Target setting to generate C source and header files.
      //
      // To use this setting, you need to compile and install protobuf-c.
      // It can be obtained from https://github.com/protobuf-c/protobuf-c
      // Make sure that "protoc-gen-c" is in PATH.
      PB.gens.plugin(name="c") -> (Compile / sourceManaged).value,
    ),
  )

//-----------------------------------------------------------------------
// This sub project hosts a C program which depends on the C source
// and header files generated by the "proto" sub project.
//
// This sub project finally generates a jar file including the compiled
// C program so that the C program can be executed by another Java
// program.
//-----------------------------------------------------------------------
lazy val cprog = (project in file ("cprog"))
  .enablePlugins(CcPlugin)
  .settings(
    Compile / ccTargets := ListSet(cprogExe),

    Compile / cSources := Map(
      cprogExe -> Seq(
        (Compile / sourceDirectory).value / "c" / "cprog.c",
      )
    ),

    Compile / cSourceFiles := { CcPlugin.combineMaps(
      (Compile / cSources).value,

      // Compile the C source files generated in "proto" sub project.
      Map( cprogExe -> FileTreeView.default.list(Glob((proto / Compile / sourceManaged).value / "*.pb-c.c")).map(_._1.toFile) )
    ) },

    // Run "compile" in "proto" sub project first to generate the C source files, then
    // compile this sub project.
    Compile / compile := ((Compile / compile) dependsOn (proto / Compile / compile)).value,

     Compile / ldFlags := Map(
      cprogExe -> Seq("-lprotobuf-c")
    ),
  )

